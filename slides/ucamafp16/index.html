<section data-markdown class="title center">
  <script type="text/template">
    # Modular Operating System Construction <br />

    Anil Madhavapeddy, University of Cambridge
    <br />
    ACS Advanced Functional Programming
    <br />

    <div style="font-size: 24pt">
      __Homepage__: [http://openmirage.org](http://openmirage.org)
      <br />
      __Slides__: [http://decks.openmirage.org/cam13/](http://decks.openmirage.org/facebook13/#/)
      <br />
      __Screencast__: [http://youtu.be/2Mx8Bd5JYyo](http://www.youtube.com/watch?v=2Mx8Bd5JYyo)
    </div>
    <br />
    <small>Press &lt;esc&gt; to view the slide index, and the &lt;arrow&gt; keys to navigate.</small>
 </script>
</section>

<section>
  <section data-markdown>
    <script type="text/template">
    ## These Slides Are...

    - Hosted on a <b>small Xen microkernel written in statically
    type-safe OCaml</b>, including the device drivers and TCP stack.

    - The application code was just a <b>couple of source files</b>, with
    all the hard work done in the MirageOS toolchain.

    - The kernel is <b>running on the public cloud</b> on Amazon EC2, with
    the binaries tracked in GitHub.

    <br />

    I'll explain how this all fits together works during this talk!

    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
      ## OS Virtualization (Xen)

      <img src="threat-model.png" />

      <div class="fragment">
        <img class="arrow"
             style="top: -320pt; left: 290pt; height: 6cm;"
             src="red-arrow.png" />

        <img class="arrow"
             style="top: -190pt; left: 180pt; height: 6cm;
                    -webkit-transform: rotate(-90deg)"
             src="red-arrow.png" />

        <img class="arrow"
             style="top: -190pt; left: 180pt; height: 6cm;
                    -webkit-transform: rotate(-90deg);"
             src="red-arrow.png" />

        <p class="bubble left"
           style="top: -344pt; left: 600pt; width: 4em" >
          Internet<br />
          SAN/NAS<br />
          Tenants<br />
          SDN
        </p>
      </div>
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## The Cloud Threat Model

      <img src="threat-model.png" />


      <div class="fragment">
        <img class="arrow"
             style="top: -320pt; left: 290pt; height: 6cm"
             src="green-arrow.png" />

        <img class="arrow"
             style="top: -190pt; left: 180pt; height: 6cm;
                    -webkit-transform: rotate(-90deg)"
             src="red-arrow.png" />

        <img class="arrow"
             style="top: -190pt; left: 180pt; height: 6cm;
                    -webkit-transform: rotate(-90deg)"
             src="red-arrow.png" />

        <p class="bubble  right"
           style="top: -440pt; left: -5pt; width: 11em">
          Type-safety in the application layer defeats several external threats.
        </p>
     </div>

      <div class="fragment">
        <img class="arrow"
             style="top: -482pt; left: 307pt; height: 6cm;
                    -webkit-transform: rotate(-90deg)"
             src="green-arrow.png" />

        <p class="bubble "
           style="top: -730pt; left: 370pt; width: 12em">
          Type-safety in the kernel will make all external I/O safe, but at what
          cost?
        </p>
      </div>

    </script>
  </section>
  <section data-markdown>
    <script type="text/template">
      ## Target the hypervisor

      <img src="key-insight.png" />
      <p class="fragment bubble "
         style="top: -270pt; left: 190pt; width: 15.5em">
        Virtual machines are UNIX processes &ldquo;done right&rdquo; on the
        cloud.
      </p>
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Key Design Insights

      <img src="key-insight.png" />

      <p class="bubble"
         style="top: -330pt; left: 220pt; width: 15em">
        The hypervisor gifts us a stable hardware interface. Cures the curse
        of research operating systems!
      </p>

      <p class="bubble left"
         style="top: -320pt; left: 380pt; width: 12em">
        Protocol-level compatibility between special-purpose cloud
        appliances, e.g. a webserver, a database VM.
      </p>

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Current Virtual Appliances

      <img src="vapps-current.png" />

      Compiler has to stop at userspace.

      Every level has a different API, calling convention, and privilege requirements.

    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
      ## Specialised Virtual Appliances

      <img src="vapps-specialised-1.png" />
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Specialised Virtual Appliances

      <img src="vapps-specialised-2.png" />
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Specialised Virtual Appliances

      <img src="vapps-specialised-3.png" />
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Contributions

      + The unikernel approach to building single-purpose appliances
        + Library OS + high level programming interface
        + Single-address space layout

      <br />

      + Evaluation of these techniques using a functional programming language
        (OCaml)
        + Benefits of type-safety need not damage performance
        + Static typing + modules = high level manipulation of OS constructs

      <br />

      + Precise source code dependency tracking of *all* the inputs to the deployed binary.

    </script>
  </section>


</section>


<section>
  <section data-markdown>
    <script type="text/template">
    ## What is an Operating System?

    > "An operating system is a collection of software that manages computer
    > hardware resources and provides common services for computer programs."

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## What is an Operating System?

    > "An operating system is a collection of software that manages computer
    > hardware resources and provides common services for computer programs."

    <br />
    While this traditionally means a monolithic OS such as Linux or Windows,
    it can also describe a **library operating system**.

    - Every OS service exposed as a library with few ambient services.
    - Application links directly with the drivers to boot (a *"unikernel"*)
    - A natural fit to the ML module system.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## A Minimal Kernel

    A simple OCaml program like this is easy to run without Unix.

	let rec qsort = function
	| [] -> []
	| pivot :: rest ->
	  let is_less x = x < pivot in
	  let left, right = List.partition is_less rest in
	  qsort left @ [pivot] @ qsort right

    **Why?**
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## A Minimal Kernel

    A simple OCaml program like this is easy to run without Unix.

	let rec qsort = function
	| [] -> []
	| pivot :: rest ->
	  let is_less x = x < pivot in
	  let left, right = List.partition is_less rest in
	  qsort left @ [pivot] @ qsort right

    **Why?** It runs sequentially, meaning that it only needs:

    - to run as native code
    - a garbage collector
    - a console log to record output
    - no concurrency
    - no significant network or disk I/O
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## A Minimal Kernel

    A simple OCaml program like this is easy to run without Unix.

	let rec qsort = function
	| [] -> []
	| pivot :: rest ->
	  let is_less x = x < pivot in
	  let left, right = List.partition is_less rest in
	  qsort left @ [pivot] @ qsort right

    **Why?** It runs sequentially, meaning that it only needs:

    - <s>to run as native code</s> &nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp; **`ocamlopt -output-obj`**
    - <s>a garbage collector</s> &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;**link OCaml runtime to Xen MiniOS**
    - <s>a console log to record output</s> &nbsp; **log to virtual machine console**
    - no concurrency
    - no significant network or disk I/O
    </script>
  </section>

   <section data-markdown>
        <script type="text/template">
          ## Kernel Memory Management

          <img class="stretch" src="memory-model.png" />

          <p class="fragment bubble"
             style="top: -410pt; left: 195pt; width: 20em; font-size: 20pt">
            Compiled native source code and runtime statically linked and boots
            directly into Xen.
          </p>

          <p class="fragment bubble  right"
             style="top: -390pt; left:-66pt; width: 12em; font-size: 20pt">
            IO memory is mapped into a reserved area and can be distinguished.
          </p>

          <p class="fragment bubble  left"
             style="top: -280pt; left: 320pt; width: 12em; font-size: 20pt">
            OCaml heap is contiguous, with simpler write barriers as a result.
          </p>

        </script>
      </section>

  <section data-markdown>
    <script type="text/template">
    ## A Minimal Kernel

    A simple OCaml program like this is easy to run without Unix.

	let rec qsort = function
	| [] -> []
	| pivot :: rest ->
	  let is_less x = x < pivot in
	  let left, right = List.partition is_less rest in
	  qsort left @ [pivot] @ qsort right

    **Why?** It runs sequentially, meaning that it only needs:

    - <s>to run as native code</s> &nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp; **`ocamlopt -output-obj`**
    - <s>a garbage collector</s> &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;**link OCaml runtime to Xen MiniOS**
    - <s>a console log to record output</s> &nbsp; **log to virtual machine console**
    - no concurrency
    - no significant network or disk I/O
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## A Minimal Kernel

    A simple OCaml program like this is easy to run without Unix.

	let rec qsort = function
	| [] -> []
	| pivot :: rest ->
	  let is_less x = x < pivot in
	  let left, right = List.partition is_less rest in
	  qsort left @ [pivot] @ qsort right

    **Why?** It runs sequentially, meaning that it only needs:

    - <s>to run as native code</s> &nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp; **`ocamlopt -output-obj`**
    - <s>a garbage collector</s> &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;**link OCaml runtime to Xen MiniOS**
    - <s>a console log to record output</s> &nbsp; **log to virtual machine console**
    - **implement language-level concurrency via monads**
    - **build device drivers via modular blocks**
    </script>
  </section>
</section>


<section>
  <section data-markdown>
    <script type="text/template">
    ## Monads

	module type MONAD = sig
	  type α t
	  val bind : α t -> (α -> β t) -> β t
	  val return :  α -> α t
	end

* A monad is a box that contains an abstract value.
* Put values in the box with `return`
* Transform them into other values with `bind`

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## The Option Monad

    Let's implement a monad that expresses optional values, starting in the OCaml interactive toplevel.

	# Some "apple" ;;
	- : string option = Some "apple"

	# None ;;
	- : 'a option = None

	# let return x = Some x ;;
	val return : 'a -> 'a option = <fun>

	# let maybe u f =
	  match u with
	  | Some c -> f c
	  | None   -> None ;;
	val maybe : 'a option -> ('a -> 'b option) -> 'b option = <fun>

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Option Monad: definition

	module OptionMonad = struct
	  type α t = α option

	  let bind u f =
	   match f with
		| Some x -> f x
		| None   -> None

		let return u = Some u
	end

The toplevel will report the following type:

	module OptionMonad = sig
		type α t
		val bind : α t -> (α -> β t) -> β t
		val return :  α -> α t
	end

    </script>

  </section>

  <section data-markdown>
    <script type="text/template">
    ## Option Monad: definition

	module OptionMonad = struct
		type α t = α option

		let bind u f =
			match f with
			| Some x -> f x
			| None   -> None
		let return u = Some u
	end

    - The value in the box may or may not exist, so is `type α option`
    - `return` places a concrete value in the box.
    - `bind` applies a function to it if it exists, and does nothing otherwise.

    - Notice that the `f x` application in `bind` is *not* wrapped in a `Some`.

    </script>

  </section>

  <section data-markdown>
    <script type="text/template">
    ## Option Monad: examples

    Some simple uses of these definitions:

	open OptionMonad ;;
	bind
		(return 1)
		(fun c -> return (c+1)) ;;
	- : int option = Some 2

	bind
		None
		(fun c -> return (c+1)) ;;
	- : int option = None

    Binds can be chained to link the results.

	bind (
		bind
		(Some 1)
		(fun c -> return (c+1))
	) (fun c -> return (c+1)) ;;
	- : int option = Some 3

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Option Monad: infix operators

    Infix operators make chaining `bind` more natural:

	let (>>=) = bind ;;
	val ( >>= ) : 'a option -> ('a -> 'b option) -> 'b option = <fun>

	return 1 >>= fun c ->
	return (c+1) >>= fun c ->
	return (c+1) ;;
	- : int option = Some 3

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Option Monad: infix operators

    Infix operators make chaining `bind` more natural:

	let (>>=) = bind ;;
	val ( >>= ) : 'a option -> ('a -> 'b option) -> 'b option = <fun>

	return 1 >>= fun c ->
	return (c+1) >>= fun c ->
	return (c+1) ;;
	- : int option = Some 3

    Or define a `maybe_add` function to be even more succinct.

	let maybe_add c = return c + 1 ;;
	val maybe_add : int -> int option = <fun>

	return 1
	>>= maybe_add
	>>= maybe_add
	- : int option = Some 3

    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
    ## Monad Laws

	module type MONAD = sig
		type α t
		val bind : α t -> (α -> β t) -> β t
		val return :  α -> α t
	end

* Monad implementations must satisfy some laws.

    </script>

  </section>

  <section data-markdown>
    <script type="text/template">
    ## Monad Laws: left identity

	module type MONAD = sig
		type α t
		val bind : α t -> (α -> β t) -> β t
		val return :  α -> α t
	end

    `return` is a left identity for `bind`

	return x >>= f
	f x

    Using the OptionMonad:

	# return 1 >>= maybe_add ;;
	- : int option = Some 2

	# maybe_add 1;;
	- : int option = Some 2

	# return (Some 1) >>= maybe_add

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Monad Laws: right identity

	module type MONAD = sig
		type α t
		val bind : α t -> (α -> β t) -> β t
		val return :  α -> α t
	end

    `return` is a right identity for `bind`

	m >>= return
	m

    Using the OptionMonad:

	# Some 1 >>= return
	- : int option = Some 1

	# None >>= return
	- : 'a option = None

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Monad Laws: associativity

	module type MONAD = sig
		type α t
		val bind : α t -> (α -> β t) -> β t
		val return :  α -> α t
	end

    `bind` is associative (in an odd way).

	(u >>= f) >>= g
	 u >>= (fun x -> f x) >>= g

    Using the OptionMonad:

	# Some 3 >>= maybe_add >>= maybe_add ;;
	- : int option = Some 5

	# Some 3 >>= (fun x -> maybe_add x >>= maybe_add) ;;
	- : int option = Some 5

    </script>
  </section>
</section>

<section>

  <section data-markdown>
    <script type="text/template">
    ## Cooperative Concurrency

    There are quite a few uses for monads; we'll use this to build a cooperative concurrency model for our OS.

	module Lwt = struct
		type α t
		val bind : α t -> (α -> β t) -> β t
		val return :  α -> α t
	end

    The `Lwt` (Light Weight Thread) monad signature above represents a *future computation* that is held in the box.

    Can construct *futures* and compute using them by using `bind` to operate over its eventual value.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Constant threads

	open Lwt ;;
	let future_int = return 1 ;;
	val future_int : int Lwt.t = <abstr>

    Build a constant thread by using `return`.

	let future_fruit = return "apple" ;;
	val future_fruit : string Lwt.t = <abstr>

	let future_lang = return `OCaml ;;
	val future_lang : [> `OCaml] Lwt.t = <abstr>

    Threads are first-class OCaml values and parametric polymorphism lets you
    distinguish different types of threads.

    No system threads are involved at all; this is sequential code.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Concurrency: executing

	module OS = struct
		val sleep : float -> unit Lwt.t
		val run : 'a Lwt.t -> 'a
	end

    The monad needs to be *executed* to retrieve the future contents.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Concurrency: executing

	module OS = struct
		val sleep : float -> unit Lwt.t
		val run : 'a Lwt.t -> 'a
	end

    The monad needs to be *executed* to retrieve the future contents.

	let t =
		OS.sleep 1.0 >>= fun () ->
		print_endline ">> start";
		OS.sleep 2.0 >>= fun () ->
		print_endline ">> woken up";
		return () ;;
	val t : unit Lwt.t = <abstr>

    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
    ## Concurrency: executing

	module OS = struct
		val sleep : float -> unit Lwt.t
		val run : 'a Lwt.t -> 'a
	end

    The monad needs to be *executed* to retrieve the future contents.

	let t =
		OS.sleep 1.0 >>= fun () ->
		print_endline ">> start";
		OS.sleep 2.0 >>= fun () ->
		print_endline ">> woken up";
		return () ;;
	val t : unit Lwt.t = <abstr>

	OS.run t ;;
	>> start
	>> woken up

    The `run` function takes a future and unpacks the real value.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Joinad: not quite a monad

	module Lwt = struct
		type α t
		val bind : α t -> (α -> β t) -> β t
		val return :  α -> α t

		val join : unit t list -> unit t
		val choose : α t list -> α t
	end

    We extend the `MONAD` signature with:

    - `join` to wait for a list of threads to terminate.
    - `choose` to return as soon as one thread of a list completes.
    - `join` is also defined as the `<&>` operator, and `choose` as `<?>`.

    <br/>
    *(see [tomasp.net](http://tomasp.net) and [tryjoinads.org](http://tryjoinads.org) for more background)*

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Example: flip a coin

	module Lwt = struct
		type α t
		val bind : α t -> (α -> β t) -> β t
		val return :  α -> α t

		val join : unit t list -> unit t
		val choose : α t list -> α t
	end

    Using `choose` to pick the first thread in a coin flip:

	let flip_a_coin () =
		let heads =
		  OS.sleep 1.0 >>= fun () ->
		  return (OS.log "Heads") in
		let tails =
		  OS.sleep 2.0 >>= fun () ->
		  return (OS.log "Tails") in
		heads <&> tails

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Representation of a thread

	type 'a t = {
		| Return of 'a
		| Fail of exn
		| Sleep of 'a sleeper
	}
	and sleeper = {
		waiters : 'a waiter_set;
		<...etc>
	}

    Thread has three main states:

    - It has **completed** and contains a concrete `Return` value.
    - It has **failed** and contains a concrete `Fail` exception.
    - It is **blocked** and waiting on another thread.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Wakeners and tasks

    Each thread executes until it needs to wait on a resource.  It creates
    a *task* to let it be woken up in the future.

	type 'a t  (* thread *)
	type 'a u  (* wakener *)
	val wait : unit -> 'a t * 'a u
	val wakeup : 'a u -> 'a -> unit

    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
    ## Wakeners and tasks

    Each thread executes until it needs to wait on a resource.  It creates
    a *task* to let it be woken up in the future.

	type 'a t  (* thread *)
	type 'a u  (* wakener *)
	val wait : unit -> 'a t * 'a u
	val wakeup : 'a u -> 'a -> unit

    Tasks are a pair: a thread that sleeps until it is fulfilled via its wakener by calling `wakeup` on it.

	let t1 =
	  t >>= fun x ->
	  print_endline x;
	  return ()
	and t2 =
	  OS.sleep 2.0 >>= fun () ->
	  wakeup u "x";
	  return ()

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Wakeners: building a timer

    Wakeners are enough to build our `OS.sleep` function:

    - Call `sleep` with `t` seconds as an argument.
    - Create a thread `t` and a wakener `u`.
    - Insert `u` into a priority queue of timeouts, ordered by duration.
    - The application sleeps on `t` until `u` is invoked by the scheduler.

    <br />
    The priority queue is a standard data structure ordered by duration.

	module Sleep_queue =
		Lwt_pqueue.Make(struct
			type t = sleeper
			let compare { time = t1 } { time = t2 } = compare t1 t2
		end)
	end

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Wakeners: running in Unix

    The `OS.main` function runs until all threads are blocked,
    and then drops into the `select` function to wait for the next timeout.

	run main thread (threads register timeouts)
	if result is Blocked then
		T = head of priority queue
		select() for T seconds
		wakeup timeouts
	repeat until main thread result is Done or Fail

     - This lets our sequential code be fully concurrent, without preemptive system threads.
     - Number of threads limited only by OCaml heap size.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Wakeners: running in Xen

    Lwt uses the `select` system call in Unix, which blocks the process until some IO event (or a timeout) occurs.

    **But how does this translate to Xen?**

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Wakeners: running in Xen

    Lwt uses the `select` system call in Unix, which blocks the process until some IO event (or a timeout) occurs.

    Xen has an equivalent *VM block instruction* which suspends the whole VM until a device interrupt or timeout.

    > **processes in Unix** <=> **Virtual Machines in Xen**

    > **`select` in Unix** <=> **block entire virtual machine in Xen**

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Wakeners: running in Xen

    Lwt uses the `select` system call in Unix, which blocks the process until some IO event (or a timeout) occurs.

    Xen has an equivalent *VM block instruction* which suspends the whole VM until a device interrupt or timeout.

    > **processes in Unix** <=> **Virtual Machines in Xen**

    > **`select` in Unix** <=> **block entire virtual machine in Xen**

    Our Xen VM can use this abstraction for all its I/O and timing.

    **Question: What is the major downside of this approach?**
    </script>
  </section>


</section>

<section>

  <section data-markdown>
    <script type="text/template">
      ## MirageOS Workflow

      - Write a normal bit of OCaml source code.

      ```
let main () =
    lwt zones = read key "zones" "zone.db" in
    Net.Manager.bind (fun mgr dev ->
        let src = `any_addr, 53 in
        Dns.Server.listen dev src zones
    )
```
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## MirageOS Workflow

      - Write a normal bit of OCaml source code.
      - Write a configuration file for the compilation.

      ```
      # ip-use-dhcp: true
      ip-address: 10.0.0.2
      ip-netmask: 255.255.255.0
      ip-gateway: 10.0.0.1
      fs-static: ../storage
      main-ip: Ping.main
      depends: mirage-net
      ```

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## MirageOS Workflow

      - Write a normal bit of OCaml source code.
      - Write a configuration file for the compilation.
      - Compile it under UNIX using the OPAM package manager.

      ```
$ opam install mirage-unix mirage-www
$ mirari run --unix
      ```

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## MirageOS Workflow

      - Write a normal bit of OCaml source code.
      - Write a configuration file for the compilation.
      - Compile it under UNIX using the OPAM package manager.
      - Once debugged, just recompile the same source code to Xen!

      ```
$ opam install mirage-xen mirage-www
$ mirari run --xen
$ xl create -c mirage-www.conf
      ```

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## MirageOS Workflow

      - Write a normal bit of OCaml source code.
      - Write a configuration file for the compilation.
      - Compile it under UNIX using the OPAM package manager.
      - Once debugged, just recompile the same source code to Xen!
      - The magic happens via the OCaml module system.

    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
      ## Modularizing the OS

      <img src="modules1.png" />

    </script>
  </section>


   <section data-markdown>
    <script type="text/template">
      ## Modularizing the OS

      <img src="modules2.png" />

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Modularizing the OS

      <img src="modules3.png" />

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Building these modules

      OPAM includes a SAT-solver to pick modules for a given hardware target *(can include Xen vs Linux dom0+Xen vs kFreeBSD)*

      Libraries are lightweight and independent (on GitHub):

      - **[mirage/ocaml-xenstore](https://github.com/mirage/ocaml-xenstore)** - abstract, Unix/Xen interface.
      - **[mirage/shared-memory-ring](https://github.com/mirage/shared-memory-ring)** - shared memory protocol for Xen drivers.
      - **[mirage/ocaml-xen-block-driver](https://github.com/mirage/ocaml-xen-block-driver)** - Unix/Xen Blkfront/Blkback.
      - **[mirage/ocaml-vchan](https://github.com/mirage/ocaml-vchan)** - Unix/Xen Vchan shared memory transport.
      - **[mirage/mirage-platform](https://github.com/mirage/mirage-platform)** - UNIX/Xen/NS3 versions of timer, shared memory and event channels.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Example: Blkfront

      ```
module type BLOCK_DEVICE = sig
  type t
  type 'a io
  type page_aligned_buffer
  type error =
  | Unknown of string

  type info = {
    read_write: bool;    (** True if we can write, false if read/only *)
    sector_size: int;    (** Octets per sector *)
    size_sectors: int64; (** Total sectors per device *)
  }

  val get_info: t -> info io
  val read: t -> int64 -> page_aligned_buffer list ->
     [ `Error of error | `Ok of unit ] io
  val write: t -> int64 -> page_aligned_buffer list ->
     [ `Error of error | `Ok of unit ] io
end

```

    </script>
  </section>



</section>
